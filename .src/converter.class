' Gambas class file

Create Static
Create Private

Public sGambas As String[]
Public sPartes As String[]
Public sLine As String
Public iIndex As Integer
Public iSpaces As Integer
Public sComments As String

Public cDictionary As New Collection

Public cFunctions As New Collection   ' acumulo las funciones que voy encontrando
Public SelectOpen As Boolean
Public ForOpen As Boolean
Public EndOpen As Boolean
Public IfOpen As Boolean

Public Sub Init()

  ' armo el diccionario de reemplazos, ojo se consideran mayusculas
  ' valor = Vala, key = Gambas

  ' tipos
  cDictionary.Add("double", "Float")
  cDictionary.Add("integer", "Integer")
  cDictionary.Add("float", "Single")
  cDictionary.Add("string", "String")

  ' estructuras de control
  cDictionary.Add("swich (", "Select Case") 'requiere un ) final
  cDictionary.Add("foreach (", "For Each")  'requiere un ) final
  cDictionary.Add("for (", "For")           'requiere un ) final
  cDictionary.Add("in", "In")
  cDictionary.Add("}", "End If")
  cDictionary.Add("}", "Endif")
  cDictionary.Add("if (", "If")             'requiere un ) final
  cDictionary.Add("}", "End Select")
  cDictionary.Add("}", "Next")
  cDictionary.Add("}", "End")
  cDictionary.Add("while (", "Do While")    'requiere un ) final
  cDictionary.Add("do {", "Do")
  cDictionary.Add("}", "Loop")
  cDictionary.Add(") @", "Then")
  cDictionary.Add("default", "Case Else")
  cDictionary.Add("} else {", "Else")
  cDictionary.Add("case", "Case")

  ' declaraciones
  cDictionary.Add("", "Fast")
  cDictionary.Add("@", "Function")
  cDictionary.Add("void", "Sub")
  cDictionary.Add("", "Procedure")
  cDictionary.Add("static public", "Static Public")
  cDictionary.Add("public", "Public")
  cDictionary.Add("", "Optional")

  ' sentencias
  cDictionary.Add("return", "Return")
  cDictionary.Add("public", "Public")
  cDictionary.Add("public", "Public")
  cDictionary.Add("public", "Public")
  cDictionary.Add("public", "Public")

  ' Math
  cDictionary.Add("Math.sin", "Sin")
  cDictionary.Add("Math.cos", "Cos")
  cDictionary.Add("Math.tan", "Tan")
  cDictionary.Add("Math.PI", "Pi")

End

Public Sub Convert()

  Dim sVala, sGB As String

  Dim sPartes As String[], s, s2 As String

  FMain.txtValaCode.Clear
  sGambas = Split(FMain.txtGambasCode.Text, gb.Cr & gb.CrLf)
  iIndex = 0

  Do
    ConvertLine()

    If iIndex >= sGambas.Count Then Break
  Loop

End

Public Sub ConvertLine()

  Dim s, s2 As String
  Dim p As Integer
  Dim f As Float

  EndOpen = False
  IfOpen = False
  ForOpen = False
  SelectOpen = False
  f = 5 + Cos(Pi)

  ' leo una linea
  ReadLine

  ' extraigo comentarios finales
  p = Instr2(sLine, "'", 1)
  If p > 0 Then
    sComments = Mid(sLine, p)
    sLine = Trim(Left(sLine, p - 1))
  Endif

  ' extraigo cosas que no sirven
  sLine = Replace2(sLine, "Fast ", "")

  ' chequeo que haya quedado codigo
  If SLine = "" Then
    WriteLine("")
    Return
  End If
  ' separo las palabras
  sPartes = Split(sLine, " ", Chr(34), True, True)
  If sPartes.Count = 0 Then Return
  Select Case Lower(sPartes[0])

    Case "public", "private", "function", "sub", "property", "procedure", "dim", "static"
      ConvertDeclares()
    Case Else
      ConvertLang()

  End Select

  ' post procesado
  Return

End

'' convierto las estructuras de control condicionales
Public Sub ConvertConditional()

  Dim sVala, sCondi, sSentencia As String
  Dim p As Integer

  Dim i As Integer

  p = Instr2(sline, "@")

  If Right(sline, 1) = "@" Then    ' es un If de varias lineas
    sline = Left(sLine, Len(sline) - 1) & "{"
  Else
    sLine = Left(sLine, p - 1) & ConvertSentences(Mid(sline, p + 1))
  End If

End

'' convierto los loops
Public Sub ConvertLoop()

  Dim sVala, sCondi, sSentencia As String
  Dim i As Integer

End

Public Function ConvertSentences(sInstruction As String) As String

  If Right(sInstruction, 1) = "{" Then Return sInstruction
  If Right(sInstruction, 1) = "}" Then Return sInstruction
  Return sInstruction & ";"

End

Public Function FindIndex(sToFind As String) As Integer

  Dim i, i2 As Integer, s As String

  ' obtengo el tipo de la declaracion
  For i = 0 To sPartes.Max
    s = Lower(sPartes[i])
    If s = sToFind Then Return i
  Next
  Return -1

End

Public Function FindLastIndex(sToFind As String) As Integer

  Dim i, i2 As Integer, s As String

  i2 = -1
  For i = 0 To sPartes.Max
    s = Lower(sPartes[i])
    If s = sToFind Then i2 = i

  Next
  Return i2

End

Public Function ConvertDeclares() As String  ' convierte

  ' Fast Public Static Sub/Function/Procedure(s1 As Integer, Optional s2 as String[]= ["2","tiuch"], e as float = 3) as Integer    ' esto es una test
  ' Public a as string = "test"

  Dim s, sType, sDeclare, sArgs, sName As String = "eoo", i, i2, i3 As Integer = 9
  Dim isProcedure As Boolean

  ' obtengo el tipo de la declaracion
  i = InStr(sLine, ")", -1000)
  Try sType = Mid(SLine, i + 4)
  If sType <> "" Then sType = GetType(sType) Else sType = "void"

  i = InStr(sLine, "(")
  i2 = InStr(sLine, "=")

  If i > 0 Then
    If (i2 > 0) And (i2 < i) Then
      isProcedure = False
    Else
      isProcedure = True
    End If
  Else ' no hay ()
    isProcedure = False
  Endif

  If isProcedure Then
    i2 = InStr(sLine, ")", -1000)
    i3 = InstrReverse(sLine, " ", i)
    sArgs = Trim(Mid(sLine, i + 1, i2 - i - 1))
    If sArgs = "" Then sargs = " void "

    sName = Mid(sLine, i3 + 1, i - i3 - 1)

    ' reconstruyo
    ' public/private/static
    sDeclare = ""
    i = 0
    Do
      Select Case Lower(sPartes[i])
        Case "public", "private", "property", "static"

          sDeclare &= Lower(sPartes[i]) & " "
        Case "function", "sub", "procedure"

        Case Else
          Break
      End Select
      Inc i
    Loop

    ' agrego el tipo y el nombre
    sDeclare &= sType & " " & sName
    sArgs = ConvertArgs(sArgs)
    ' agrego los argumentos
    sDeclare &= "(" & sArgs & ") {"

    WriteLine(sDeclare)

  Else
    ' es una declaracion de variable, por ej:
    ' Dim s, sType, sDeclare, sArgs, sName As String = "eoo", i, i2, i3 As Integer = 9
    ' Public Const e as integer = 4
    ' puede haber varias delaraciones en una linea lo que dificulta la traduccion
    Dim sDeclareType, sVarList, sValue As String
    Dim slxVarList As String[]
    Select Case sPartes[0]
      Case "Dim"
        sDeclareType = ""
        sline = Mid(sLine, 5)
      Case "Public"
        sDeclareType = "public "
        sline = Mid(sLine, 7)
      Case "Private"
        sDeclareType = "private "
        sline = Mid(sLine, 8)
      Case "Property"
        sDeclareType = "property "
        sline = Mid(sLine, 9)

    End Select

    If sPartes[1] = "Const" Then
      sDeclareType = "const "
      sline = Mid(sLine, 13)
    End If

    ' ya trunque el tipo de declaracion, me queda el resto:
    ' s, sType, sDeclare, sArgs, sName As String = "errro", i, i2, i3 As Integer = 9

    Do

      i2 = InStr(sLine, " As ")
      If i2 = 0 Then Break
      ' y el tipo es:
      sType = Mid(sline, i2 + 4)
      sVarList = Left(sline, i2)
      slxVarList = Split(sVarList, ",")

      If slxVarList.Count = 0 Then
        slxVarList.Add(sVarList)
      Endif

      ' veo si es declaracion multiple
      i3 = InStr(sType, ",")
      If i3 > 0 Then
        sline = Mid(sType, i3 + 1)
        sType = Mid(sType, 1, i3 - 1)
      Else
        sline = ""
      Endif

      ' veo si ya le asgna valor
      i3 = InStr(sType, "=")
      If i3 > 0 Then
        sValue = Mid(sType, i3)
        sType = Left(sType, i3 - 1)
      Else
        sValue = ""

      End If
      sType = GetType(sType)

      ' ahora puedo armar esta parte
      For i = 0 To slxVarList.Max
        sVarList = slxVarList[i]
        sVarList = " " & Trim(sVarList) & " "
        WriteLine(sDeclareType & sType & sVarList & sValue & ";", IIf(i <= slxVarList.Max, True, False))
      Next

    Loop

  Endif

End

'' Convierte: i As Integer, e3 as Float, slxBase as String[]  -> integer i, double e3, string[] slxbase
Public Function ConvertArgs(sArguments As String) As String

  Dim slxArg As String[]
  Dim sArg As String
  Dim i, pEqual As Integer
  Dim sVar As String
  Dim sType, sResult, sValue As String

  sArguments = Replace2(sArguments, "Optional", "")

  slxArg = Split(sArguments, ",")

  For Each sArg In slxArg
    i = InStr(sArg, " As ")
    sVar = Trim(Left(sArg, i - 1))
    sType = Mid(sArg, i + 4)

    pEqual = Instr2(sType, "=")
    If pEqual > 0 Then ' es un Optional
      sValue = Trim(Mid(sType, pEqual))
      sType = Left(sType, pEqual - 1)
    Else
      sValue = ""
    End If
    sType = Trim(GetType(sType))
    sResult &= sType & " " & sVar & sValue & ", "
  Next
  If Right(sResult, 2) = ", " Then
    sResult = Left(sResult, -2)
  Endif
  Return sResult

End

Public Function GetType(gbType As String) As String

  Dim sBrackets As String

  gbType = Trim(Lower(gbType))
  sBrackets = Right(gbType, 2)
  If sBrackets <> "[]" Then
    sBrackets = ""
  Else
    gbType = Left(gbType, -2)
  End If
  If gbType = "float" Then Return "double" & sBrackets
  If gbType = "single" Then Return "float" & sBrackets
  If gbType = "integer" Then Return "integer" & sBrackets
  If gbType = "string" Then Return "string" & sBrackets
  If gbType = "boolean" Then Return "bool" & sBrackets
  If gbType = "long" Then Return "long" & sBrackets

End

Public Function ConvertBool(sIn As String) As String

  Select Case Lower(sIn)
    Case "="
      Return "=="
    Case "&"
      Return "&&"
    Case "or"
      Return "||"
    Case "not"
      Return "!="
    Case Else
      Return sIn

  End Select

End

Public Function ConvertLogic(sIn As String) As String

  Select Case Lower(sIn)
    Case "="
      Return "=="
    Case "&"
      Return "&&"
    Case "or"
      Return "||"
    Case "not"
      Return "!"
    Case "xor"
      Return "^"

    Case Else
      Return sIn

  End Select

End

Public Sub ConvertLang()

  Dim s, sOut As String
  Dim p, p1, p2, p3 As Integer
  Dim sVarName, sCondition, sChange As String

  ' la divido
  sPartes = Split(sLine, " ()", Chr(34), True, True)

  For Each s In sPartes
    If Left(s, 1) = "\"" Then Continue          'ignoro todo lo que sea una cadena
    For Each s In cDictionary
      'If cDictionary.Key = "Cos" Then Stop
      sLine = Replace2(sLine, cDictionary.Key, s)
    Next

  Next

  sLine = Trim(sLine)

  'Return sLine

  ' post procesado
  ' la divido
  sPartes = Split(sLine, " ", Chr(34), True, True)

  If sPartes.Count = 0 Then                               ' es una linea en blanco
    WriteLine("")
    Return
  Endif

  ' analizo
  Select Case Lower(sPartes[0])
    Case "if"       ' if (condition) @
      ConvertConditional()
    Case "case", "default"
      sLine &= ":"
    Case "foreach", "swich"
      sLine &= ") {"
      
    Case "for"
      
      '   ConvertLoop()
      ' Case "public", "private", "function", "sub", "property", "procedure", "dim", "static"
      '   ConvertDeclares()
      '
      '   ' Case "'", "''"
      '   '   WriteLine("// " & Mid(sLine, 1))
      '
      ' Case "else"
      '   If sPartes.Count > 1 Then ' puede haber un if
      '     If Lower(sPartes[1]) = "if" Then
      '
      '     Endif
      '   Else
      '
      '     WriteLine("} else {")
      '   End If
      ' Case "end", "endif"
      '   WriteLine("}")

    Case Else
      sLine = ConvertSentences(sLine)

  End Select

  ' post process 1
  ' la divido
  sPartes = Split(sLine, " ", Chr(34), True, True)

  ' analizo
  Select Case Lower(sPartes[0])

    Case "for"  ' for (i=0 to max step some)
      p1 = Instr2(sLine, "=")
      p = Instr2(sLine, "(")
      p2 = Instr2(sLine, " Step ")
      p3 = Instr2(sLine, " To ")

      sVarName = Trim(Mid(sline, p + 1, p1 - p - 1))
      If p2 > 0 Then
        sChange = sVarName & " + " & Mid(SLine, p2 + 6)
        sCondition = sVarName & " <= " & Mid(sLine, p3 + 4, p2 - p3 - 4)
      Else
        sChange = sVarName & " + 1"
        sCondition = sVarName & " <= " & Mid(sLine, p3 + 4)
      End If

      sLine = Mid(sLine, 1, p3 - 1) & "; " & sCondition & "; " & sChange & ") {"

  End Select

  WriteLine(sLine)

End

Private Sub ReadLine()

  Dim i As Integer

  sLine = sGambas[iIndex]
  ' cuento los espacios
  iSpaces = 0
  For i = 1 To sLine.Len
    If Mid(sLine, i, 1) = " " Then
      Inc iSpaces
    Else
      Break
    Endif
  Next
  sLine = Trim(sLine)

  ' extraigo los comentarios
  i = Instr2(sLine, "'", 1)
  If i > 0 Then
    sComments = Mid(sLine, i)
    sComments = " " & Replace(sComments, "'", "//")
    sLine = Left(sLine, i - 1)
  Endif
  Inc iIndex

End

Private Sub WriteLine(sText As String, Optional KeepSpaces As Boolean = False)

  FMain.txtValaCode.Text &= String(iSpaces, " ") & sText & sComments & gb.Lf
  sComments = ""
  If Not KeepSpaces Then iSpaces = 0

End

'' Igual que Instr pero busca desde iStat hacia atras
Public Function InstrReverse(sFrase As String, sToFind As String, iStart As Integer) As Integer

  Dim i As Integer
  Dim sFrase2, sToFind2 As String

  For i = Len(sFrase) To 1 Step -1
    sFrase2 &= Mid(sFrase, i, 1)
  Next

  For i = Len(sToFind) To 1 Step -1
    sToFind2 &= Mid(sToFind, i, 1)
  Next

  Return Len(sFrase2) - InStr(sFrase2, sToFind2, Len(sFrase2) - iStart + 1) + 1

End

'' Igual q Instr pero no busca dentro de comillas
Public Function Instr2(sFrase As String, sToFind As String, Optional iStart As Integer = 1) As Integer

  Dim i As Integer

  Dim inxQuotes As New Integer[]
  Dim i2 As Integer
  Dim iResult As Integer

  For i = 1 To sFrase.Len
    If Mid(sFrase, i, 1) = Chr(34) Then inxQuotes.Add(i)
  Next

  i2 = iStart - 1
  Do

    i2 = InStr(sFrase, sToFind, i2 + 1)

    ' veo si cayo entre comillas
    ' hola ' comoe " 'digo "  que no y ahora ' si
    If i2 > 0 Then
      iResult = i2
      For i = 0 To inxQuotes.Max - 1 Step 2
        If i2 >= inxQuotes[i] And i2 <= inxQuotes[i + 1] Then
          iResult = 0
        Else
          iResult = i2
          Break
        Endif
      Next

    Endif
    If iResult > 0 Then Break
    If i2 = 0 Then Break
  Loop

  Return iResult

End

'' Reemplaza solo si no esta entre comillas
Public Function Replace2(sOrigen As String, sToFind As String, sReemplazo As String, Optional SoloPalabrasEnteras As Boolean = True) As String

  Dim s As String
  Dim p As Integer
  Dim OkInicio As Boolean

  p = 1
  Do
    p = Instr2(sOrigen, sToFind, p)
    If p = 0 Then Break

    If SoloPalabrasEnteras Then
      OkInicio = False
      If p = 1 Then
        OkInicio = True
      Else
        If (Mid(sOrigen, p - 1, 1) <> " ") And (Mid(sOrigen, p - 1, 1) <> "(") Then OkInicio = False Else OkInicio = True
      End If
      If p + Len(sToFind) < Len(sOrigen) Then
        If (Mid(sOrigen, p + Len(sToFind), 1) <> " ") And (Mid(sOrigen, p + Len(sToFind), 1) <> "(") And (Mid(sOrigen, p + Len(sToFind), 1) <> ")") Then OkInicio = False Else OkInicio = True
      Else
        OkInicio = True
      Endif
      If Not OkInicio Then
        p += Len(sToFind)

        Continue
      End If
    Endif

    sOrigen = Left(sOrigen, p - 1) & sReemplazo & Mid(sOrigen, p + Len(sToFind))
    p += Len(sReemplazo)

  Loop

  Return sOrigen

End
